#k8s 

- pod - элементарная единица управления в k8s. Может содержать несколько *сильно-зависимых* контейнеров
- replicaSet - абстракция, которая нужна для отслеживания в кластере верного кол-ва рабочих подов. Содержит темплейт для создания подов
- deployment - абстракция, которая нужна для управления развертыванием приложения. Deployment создает внутри себя и управляет replicaSet

- При скейлинге вниз есть несколько критериев как k8s выбирает, какой pod убить, в частности, убивается самый молодой pod
- kubectl позволяет менять на лету какие-нибудь настройки в подах внутри replicaSet, например image
	`kubectl set image ...`
	При этом изменения будут только в новых подах, работающие поды не будут изменяться
- Также можно пропатчить deployment
	`kubectl patch deployment <name> --patch '......'`
- Полезная документация по кубу
	`kubectl explain ...`
	Например `kubectl explain pod` или `kubectl explain pod.spec.containers`
- При завершении пода, k8s посылает ему SIGTERM, и есть `terminationGracePeriodSeconds` (default 30 sec) на остановку контейнера.
	Если контейнер не умеет обрабатывать SIGTERM, то он завершиться сразу. Что делать? Есть *pre-/stop- hooks*
- При обновлении deployment'ов (например поменяли версию образа в поде) полезно знать, что есть возможность *легко и приятно* откатиться назад, если что-то пошло не так
	При обновлении k8s поднимает новую версию (с примененными изменениями) replicaSet, а вот старую версию не убивает, но поды, конечно, опускает.
	Тогда откатиться можно командой
	`kubectl rollout undo deployment <name>`
- Глубина хранения старых replicaSet настраивается в spec deployment  `revisonHistoryLimit` (default: 10)
- Посмотреть инфу по старым ревизиям
	`kubectl rollout history deployment <name>`
- Default `strategy` - rollingUpdate
- Вторая strategy - Recreate - опускается весь deployment, поднимается заново
- У `rollingUpdate` есть настройки (в процентах или штуках)
	- `maxSurge` - какое кол-во pod можно поднимать (по такому кол-ву за раз) относительно desired state - default 25%
	- `maxUmavailable` - какое кол-во pod можно опускать (по такому кол-ву за раз) относительно desired state - default 25%
- Для pod можно манипулировать потреблением ресурсов
	- `Limits` - верхняя планка по потреблению ресурсов
	- `Requests` - резервирование ресурсов на node для pod (k8s принимает решение, куда поместить pod)
- Ресурсы
	- `cpu`
		- `m` Unit - "milli-cpu" - 1m это 1/10 одного ядра, 1000m = 1 (ядро)
	- `memory`
- Есть QoS
	- Burstable - в приложении нет requests или limits > requests
		Уезжает во вторую очередь с node при дефиците ресурсов на node
	- Best effort - в приложении нет limits, requests. Приложение может работать на сколь малых ресурсах
		Этот класс подов будет уезжать с node первым при дефиците ресурсов на node
	- Guarantee - limits == requests
		k8s будет держать это pod до последнего
- Pod STATUS
	- Running - под стартовал и работает
	- Scheduled - нет ни одной node, куда можно поместить pod (по requests)