#psql #wal 

- `wal_recycle` (`boolean`) Если этот параметр имеет значение `on` (по умолчанию), файлы WAL используются повторно (для этого они переименовываются), что избавляет от необходимости создавать новые файлы. В файловых системах COW может быть быстрее создать новые файлы, поэтому данный параметр позволяет отключить это поведение.
- Postgresql архивирует *завершенные* сегменты, т.е. запускает команду архивации, когда сегмент заполнится
- Команда архивирования вызывается, только когда сегмент WAL заполнен до конца. Таким образом, если сервер постоянно генерирует небольшой трафик WAL (или есть продолжительные периоды, когда это происходит), между завершением транзакций и их безопасным сохранением в архиве может образоваться большая задержка. Чтобы ограничить время жизни неархивированных данных, можно установить [archive_timeout](https://postgrespro.ru/docs/postgrespro/9.5/runtime-config-wal#guc-archive-timeout), чтобы сервер переключался на новый файл сегмента WAL как минимум с заданной частотой. Заметьте, что неполные файлы, архивируемые досрочно из-за принудительного переключения по тайм-ауту, будут иметь тот же размер, что и заполненные файлы. Таким образом, устанавливать очень маленький `archive_timeout` — неразумно; это приведёт к неэффективному заполнению архива. Обычно подходящее значение `archive_timeout` — минута или около того.
- Не важно, с какой скоростью работает команда архивирования, если только она не ниже средней скорости, с которой сервер генерирует записи WAL. Обычно работа продолжается, даже если процесс архивирования немного отстаёт. Если же архивирование отстаёт значительно, это приводит к увеличению объёма данных, которые могут быть потеряны в случае аварии. При этом каталог `pg_xlog/` будет содержать большое количество ещё не заархивированных файлов-сегментов, которые в конце концов могут занять всё доступное дисковое пространство. Поэтому рекомендуется контролировать процесс архивации и следить за тем, чтобы он выполнялся как задумано.
- The number of WAL segment files in `pg_wal` directory depends on `min_wal_size`, `max_wal_size` and the amount of WAL generated in previous checkpoint cycles. When old log segment files are no longer needed, they are removed or recycled (that is, renamed to become future segments in the numbered sequence). If, due to a short-term peak of log output rate, `max_wal_size` is exceeded, the unneeded segment files will be removed until the system gets back under this limit. Below that limit, the system recycles enough WAL files to cover the estimated need until the next checkpoint, and removes the rest. The estimate is based on a moving average of the number of WAL files used in previous checkpoint cycles. The moving average is increased immediately if the actual usage exceeds the estimate, so it accommodates peak usage rather than average usage to some extent. `min_wal_size` puts a minimum on the amount of WAL files recycled for future usage; that much WAL is always recycled for future use, even if the system is idle and the WAL usage estimate suggests that little WAL is needed.
- Независимо от `max_wal_size` самые последние [wal_keep_size](https://runebook.dev/ru/docs/postgresql/runtime-config-replication#GUC-WAL-KEEP-SIZE) мегабайты файлов WAL плюс один дополнительный файл WAL сохраняются все время. Кроме того, если используется архивация WAL, старые сегменты не могут быть удалены или переработаны до тех пор, пока они не будут заархивированы. Если архивирование WAL не успевает за темпом создания WAL или если `archive_command` или `archive_library` неоднократно дает сбой, старые файлы WAL будут накапливаться в `pg_wal` до тех пор, пока ситуация не будет решена.
- Количество файлов сегментов WAL в `pg_wal` зависит от `min_wal_size` , `max_wal_size` и количества WAL, созданного в предыдущих циклах контрольных точек. Когда старые файлы сегментов журнала больше не нужны, они удаляются или перерабатываются (то есть переименовываются в будущие сегменты в пронумерованной последовательности).
-  Оценка основана на скользящем среднем количестве файлов WAL, использованных в предыдущих циклах контрольных точек. Скользящее среднее немедленно увеличивается, если фактическое использование превышает оценку, поэтому оно в некоторой степени учитывает пиковое использование, а не среднее использование. `min_wal_size` устанавливает минимальное количество файлов WAL, перерабатываемых для будущего использования; такое количество WAL всегда перерабатывается для использования в будущем, даже если система простаивает, а оценка использования WAL предполагает, что WAL требуется немного.
- `min_wal_size` (`integer`) Пока WAL занимает на диске меньше этого объёма, старые файлы WAL в контрольных точках всегда перерабатываются, а не удаляются. Это позволяет зарезервировать достаточно места для WAL, чтобы справиться с резкими скачками использования WAL, например, при выполнении больших пакетных заданий.
- `wal_keep_segments` The last `wal_keep_segments` WAL segments are always kept around, even if that exceeds `max_wal_size` (Кажется именно его я увеличивал)